<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <title>Statistics map</title>
    <style>
    	body {
      font-family: "Helvetica Neue", Helvetica, sans-serif;;
      font-size: 12px;
      width: 960px;
      height: 500px;
      margin: 20px auto;
      }
/*geo map stroke*/
		.states {
    stroke: #999;
    fill: none;
    pointer-events: none;
    }

    .state-land{
    stroke: #999;
    fill: green;
    stroke-width: 1.5px;
    }

    .county-land {
      stroke: white;
      stroke-width: .3px;
    }
/*legend position*/
   .legend {
    position:absolute;
    left:20px;
    top:150px;
    }

   .axis text {
   font: 10px sans-serif;
   }

   .axis line, .axis path {
   fill: none;
   stroke: #000;
   shape-rendering: crispEdges;
   }

/*tooltip color*/
    .tooltip {
    background: rgba(0, 0, 0, 0.85);
    color: #f9f9f9;
    padding: 8px;
    }
    .tooltip h3 {
    margin: 0px 0px 8px;
    }
    </style>
  </head>

  <body>
    <h3>Death map</h3>
    <div id="map" align = 'center'><!-- Map container --></div>
    <script type="text/javascript">
    
//specify the dimensions for the map container. 
	var width = 960,
      active = d3.select(null),//the status of zoom event
    	height = 500;

//used to set the color range
  var highColor = "#ae017e",
      lowColor = "#fcc5c0";

	//create a SVG element in the map container and give it some dimensions.
	var svg = d3.select('#map').append('svg')
  				.attr('width', width)
  				.attr('height', height);
  var map = svg.append('g')
          .style('stroke-width', '1.5px'); 

  // set the tooltips for mouse hover
  var tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("position", "absolute")
                .style("z-index", "10")
                .style("visibility", "hidden");

  //A queue evaluates zero or more deferred asynchronous tasks with configurable concurrency
  d3.queue()
    .defer(d3.csv, 'police_killings.csv',navigate)
    .defer(d3.json, 'us.json')
    .defer(d3.json, 'us-states.json')
    .await(ready);

  // We define a geographical projection and set the initial zoom to show the features.
  var projection = d3.geoAlbersUsa()
                    .scale(1000)//adjust the size of the whole map
                    .translate([width/2, height/2]);

  var path = d3.geoPath()
               .projection(projection)
               .pointRadius(1.5);

  //extract longitute and latitude
  function navigate(d) {
  d[0] = +d.longitude;
  d[1] = +d.latitude;
  d.arcs = {type: "MultiLineString", coordinates: []};
  return d;
  }

  //reset zoom event, set the active status as false, waiting for click
  function reset() {
    active.classed('active', false);
    active = d3.select(null);
    //transition back to the us national map
    map.transition().duration(750)
       .style("stroke-width", "1.5px")
       .attr("transform", "");
     }

  // execute after loading the csv, us.json ,us-states data, the parameters order must correspond to the defer order. This is the main function when drawing a map.
	function ready(error, deaths, topology, UStates) {
      if (error) return console.warn(error);

//convert csv data to the format as 
//mapData=[{'state':'xxxx','death':1234},{'state':'xxxx','death':123},{..},...]
//statStateDeath = {'Alabama':{'death':50,'population':40,'white-share':45%,'black-share':45%,'hisoanic-share':10%},'CA':{},....}
      var statStateDeath = {};

      //change the column in csv file to a map
      for (var i = 0; i < deaths.length; i++) {
        //push the longitude and latitude in each line;
         deaths[i].arcs.coordinates.push(deaths[i]);

          var state = deaths[i].state;
          if (!statStateDeath.hasOwnProperty(state)) {
              statStateDeath[state] = {};
              statStateDeath[state]['death'] = 1;
              statStateDeath[state]['population'] = +deaths[i].pop;
              statStateDeath[state]['white-share'] = +deaths[i].share_white;
              statStateDeath[state]['black-share'] = +deaths[i].share_black;
              statStateDeath[state]['hispanic-share'] = +deaths[i].share_hispanic;
              if(deaths[i].raceethnicity == 'White'){
                statStateDeath[state]['white-death'] = 1;
                statStateDeath[state]['black-death'] = 0;
                statStateDeath[state]['hispanic-death'] = 0;
              }
              if(deaths[i].raceethnicity == 'Black'){
                statStateDeath[state]['white-death'] = 0;
                statStateDeath[state]['black-death'] = 1;
                statStateDeath[state]['hispanic-death'] = 0;
                } 
              if(deaths[i].raceethnicity == 'Hispanic/Latino'){
                statStateDeath[state]['white-death'] = 0;
                statStateDeath[state]['black-death'] = 0;
                statStateDeath[state]['hispanic-death'] = 1;
                } 

          } else {
              statStateDeath[state]['death'] += 1; 
              statStateDeath[state]['white-share'] = updateRate(statStateDeath[state]['population'], statStateDeath[state]['white-share'], +deaths[i].pop, +deaths[i].share_white);
              statStateDeath[state]['black-share'] = updateRate(statStateDeath[state]['population'], statStateDeath[state]['black-share'], +deaths[i].pop, +deaths[i].share_black);
              statStateDeath[state]['hisoanic-share'] = updateRate(statStateDeath[state]['population'], statStateDeath[state]['hispanic-share'], +deaths[i].pop, +deaths[i].share_hispanic);
              statStateDeath[state]['population'] += +deaths[i].pop;

              if(deaths[i].raceethnicity == 'White'){
                statStateDeath[state]['white-death'] += 1;
              }
              if(deaths[i].raceethnicity == 'Black'){
                  statStateDeath[state]['black-death'] += 1;
                } 
              if(deaths[i].raceethnicity == 'Hispanic/Latino'){
                  statStateDeath[state]['hispanic-death'] += 1;
                } 
            }
        };

        var mapData = [];
          for (var state in statStateDeath) {
            var pair = {};
            pair['state'] = state;
            pair['death'] = statStateDeath[state]['death'];
            mapData.push(pair);
          };

//set the color to linear scle,death = [1,2,4,21,55...]
      var death = [];
        for (var i=0; i< mapData.length; i++){
            death.push(mapData[i].death);
        };
      var color = d3.scaleLinear()
              .domain([d3.min(death),d3.max(death)])
              .range([lowColor,highColor]); 

      function mapColor(d){
            var hasColor = 0;
            for(var i in mapData){
                if(mapData[i].state == d.properties.name){
                    hasColor = 1;
                    return color(mapData[i].death);  
                }
            }
            if (hasColor == 0){
              return '#fff'
             }
        };
//set color ends

//append death dots on the map
      deathDots = deaths.filter(function(d) { return d.arcs.coordinates.length; });

      svg.append("path")
      .datum({type: "MultiPoint", coordinates: deathDots})
      .attr("class", "death-dots")
      .attr("d", path);

      //append states outline to map
        svg.append("path")
           .datum(topojson.mesh(topology, topology.objects.states, function(a, b) { 
                  return a.id !== b.id; }))
           .attr("class", "states")
           .attr("d", path);

//append path to map
      map.selectAll(".state-land")//path
         .attr("class", "state-land")
        .data(topojson.feature(UStates, UStates.objects["usa.geo"]).features)
        .enter().append("path")
        .style("fill", mapColor)
        .attr("d", path)
        //.on('click', function(state) {clickState.call(this, state, topology, countyData);})
        //.on("mouseover", mouseOverMap)
        //.on("mousemove", mouseMove)
        //.on("mouseout", mouseOut);



  //zoom out each state
        function clickState(state, topology, countyData) {
            if (active.node() == this) return reset();
            active.classed('active', false);
            active = d3.select(this).classed('active', true);

            var bounds = path.bounds(state),
                dx = bounds[1][0] - bounds[0][0],
                dy = bounds[1][1] - bounds[0][1],
                x = (bounds[0][0] + bounds[1][0])/2,
                y = (bounds[0][1] + bounds[1][1])/2,
            scale = .9 / Math.max(dx / width, dy / height),
            translate = [width / 2 - scale * x, height / 2 - scale * y];

            map.transition().duration(750)
               .style('stroke-width', 1.5 / scale + 'px')
               .attr('transform', 'translate(' + translate +')scale(' + scale + ')');

            var counties = map.selectAll('.county-land')
                           .call(drawCounties, topology, state.id, countyData);
        };

      function drawCounties(selection, topology, stateFips, countyData) {

        // Copy the GeometryCollection object (don't want to pass reference)
            var countiesGeo = Object.create(topology.objects.counties);

        // Filter down to the counties within active state
            countiesGeo.geometries = topology.objects.counties.geometries
                                    .filter(function(county) {
                          return fipsMatch(county.id, stateFips);
                    });

            var counties = selection.data(topojson.feature(topology, countiesGeo).features)

            counties.enter().append('path')
                    .attr('class', 'county-land')
                    .on('click', reset);

            counties.attr('opacity', 0)
                    .attr('d', path)
                    .style('fill', function(d) {
                        var lq = countyData.filter(function(county) { 
                                         return county.id === d.id; })
                                  .map(function(county) { return county.lq; });
                      
                        return color(lq);
                    })
                    .transition().duration(750)
                    .attr('opacity', 1);

            counties.exit()
                    .transition().duration(750)
                    .attr('opacity', 0)
                    .remove();
      };

    //mouseover event
      function mouseOverMap(d){
        var val = statStateDeath[d.properties.name];
        var fill_color = color(val["death"]);
        tooltip.html("");
        tooltip.style("visibility", "visible")
               .style("border", "3px solid " + fill_color);
       //h3 set the margin ,append all the txt show in label  
        tooltip.append("h3").text(d.properties.name);
        tooltip.append("div")
          .text("Population: " + val["population"]+ ", Deaths: "+ val["death"]);
        tooltip.append("div")
          .text("WhitePopShare: " + val["white-share"] + ", WhiteDeathsShare: "+ val["white-death"]);
        tooltip.append("div")
          .text("BlackPopShare: " + val["black-share"] + ", BlackDeathsShare: "+ val["black-death"]);
        tooltip.append("div")
          .text("HisoanicPopShare: " + val["hisoanic-share"] + ", HisoanicDeathsShare: "+ val["hispanic-death"]);

        d3.selectAll(".state-land path")
          .style("opacity", 0.3)
          .style("stroke", null);
        d3.select(this)
          .style("opacity", 1)
          .style("stroke", "#999")
          .raise();
        d3.selectAll(".states")
          .style("opacity", 0);
          };
  //hover event: Mouse Move and Move Out
      function mouseMove(d) {
              return tooltip.style("top", (d3.event.pageY-52) + "px")
                            .style("left", (d3.event.pageX+18) + "px");
      };
    
      function mouseOut(d) {
            tooltip.style("visibility", "hidden")
            d3.selectAll(".state-land path")
              .style("opacity", 1);
            d3.selectAll(".states")
              .style("opacity", 1);
      };

      drawLegend(death);

};
      function updateRate(oldPop, oldRate, addPop, addPopRate){
        var newRate = ((oldPop * oldRate) + (addPop * addPopRate))/(oldPop + addPop);
        return newRate.toFixed(1);
      };

    function drawLegend(death) {
      var w = 140, h = 300;

      var key = d3.select("body")
      .append("svg")
      .attr("width", w)
      .attr("height", h)
      .attr("class", "legend");

      var legend = key.append("defs")
      .append("svg:linearGradient")
      .attr("id", "gradient")
      .attr("x1", "100%")
      .attr("y1", "0%")
      .attr("x2", "100%")
      .attr("y2", "100%")
      .attr("spreadMethod", "pad");

      legend.append("stop")
      .attr("offset", "0%")
      .attr("stop-color", highColor)
      .attr("stop-opacity", 1);
      
      legend.append("stop")
      .attr("offset", "100%")
      .attr("stop-color", lowColor)
      .attr("stop-opacity", 1);

      key.append("rect")
      .attr("width", w - 100)
      .attr("height", h)
      .style("fill", "url(#gradient)")
      .attr("transform", "translate(20,10)");

      var y = d3.scaleLinear()
      .range([h, 0])
      .domain([d3.min(death),d3.max(death)]);

      var yAxis = d3.axisRight(y);

      key.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate(61,10)")
      .call(yAxis)
    };

    </script>
 
  </body>

</html>